/*
 * This source code is released into the public domain.
 */

module;

#include <cassert>
#include <cstdint>
#include <cstdlib>
#include <string>

#include <ucl.h>

export module nihil.ucl:integer;

import :object;

namespace nihil::ucl {

export struct integer final : object {
	using contained_type = std::int64_t;
	inline static constexpr object_type ucl_type = object_type::integer;

	// Create a new integer from a UCL object.
	integer(ref_t, ::ucl_object_t const *uobj)
		: object(nihil::ucl::ref, uobj)
	{
		if (type() != ucl_type)
			throw type_mismatch(ucl_type, type());
	}

	integer(noref_t, ::ucl_object_t *uobj)
		: object(noref, uobj)
	{
		if (type() != ucl_type)
			throw type_mismatch(ucl_type, type());
	}

	// Create a new default-initialised integer.
	integer()
		: integer(0)
	{}

	// Create a new integer from a value.
	explicit integer(contained_type value)
		: object(noref, ::ucl_object_fromint(value))
	{
		if (_object == nullptr)
			throw error("failed to create UCL object");
	}

	// Return the value of this object.
	auto value(this integer const &self) -> contained_type
	{
		auto v = contained_type{};
		auto const *uobj = self.get_ucl_object();

		if (::ucl_object_toint_safe(uobj, &v))
			return v;

		std::abort();
	}
};

/*
 * Comparison operators.
 */

export auto operator== (integer const &a, integer const &b)
	-> bool
{
	return a.value() == b.value();
}

export auto operator<=> (integer const &a, integer const &b)
	-> std::strong_ordering
{
	return a.value() <=> b.value();
}

export auto operator== (integer const &a, integer::contained_type b)
	-> bool
{
	return a.value() == b;
}

export auto operator<=> (integer const &a, integer::contained_type b)
	-> std::strong_ordering
{
	return a.value() <=> b;
}

} // namespace nihil::ucl

/*
 * This source code is released into the public domain.
 */

module;

#include <cstdlib>
#include <string>

#include <ucl.h>

export module nihil.ucl:string;

import :object;

namespace nihil::ucl {

export struct string final : object {
	using contained_type = std::string_view;
	inline static constexpr object_type ucl_type = object_type::string;

	using value_type = char const;
	using size_type = std::size_t;
	using difference_type = std::ptrdiff_t;
	using reference = value_type &;
	using pointer = value_type *;
	using iterator = pointer;

	// Create a new string from a UCL object.
	string(ref_t, ::ucl_object_t const *uobj);
	string(noref_t, ::ucl_object_t *uobj);

	// Create a new empty string.
	string();

	// Create a new UCL string from a string.
	explicit string(std::string_view value);

	// Create a new UCL string from an iterator pair.
	template<std::contiguous_iterator Iterator>
	string(Iterator first, Iterator last)
		: string(std::string_view(first, last))
	{}

	template<std::input_iterator Iterator>
	requires(!std::contiguous_iterator<Iterator>)
	string(Iterator first, Iterator last)
		: string(std::string(first, last))
	{}

	// Create a new UCL string from a range.
	string(std::from_range_t, std::ranges::range auto &&range)
		: string(std::ranges::begin(range),
			 std::ranges::end(range))
	{}

	// Return the value of this string.
	auto value(this string const &self) -> contained_type;

	// Return the size of this string.
	auto size(this string const &self) -> size_type;

	// Test if this string is empty.
	auto empty(this string const &self) -> bool;

	// Access this string's data
	auto data(this string const &self) -> pointer;

	// Iterator access
	auto begin(this string const &self) -> iterator;
	auto end(this string const &self) -> iterator;
};

/*
 * Comparison operators.
 */

export auto operator== (string const &a, string const &b) -> bool;
export auto operator<=> (string const &a, string const &b)
	-> std::strong_ordering;

/*
 * For convenience, allow comparison with C++ strings without having to
 * construct a temporary UCL object.
 */

export auto operator==(string const &lhs, std::string_view rhs) -> bool;
export auto operator==(string const &lhs, std::string const &rhs) -> bool;
export auto operator==(string const &lhs, char const *rhs) -> bool;

export auto operator<=>(string const &lhs, std::string_view rhs)
	-> std::strong_ordering;
export auto operator<=>(string const &lhs, std::string const &rhs)
	-> std::strong_ordering;
export auto operator<=>(string const &lhs, char const *rhs)
	-> std::strong_ordering;

} // namespace nihil::ucl

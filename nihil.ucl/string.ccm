/*
 * This source code is released into the public domain.
 */

module;

#include <cassert>
#include <cstdlib>
#include <string>

#include <ucl.h>

export module nihil.ucl:string;

import :object;

namespace nihil::ucl {

export struct string final : object {
	using value_type = std::string_view;

	inline static constexpr object_type ucl_type = object_type::string;

	// Create a new string from a UCL object.
	string(ref_t, ::ucl_object_t const *uobj)
		: object(nihil::ucl::ref, uobj)
	{
		if (type() != ucl_type)
			throw type_mismatch(ucl_type, type());
	}

	string(noref_t, ::ucl_object_t *uobj)
		: object(noref, uobj)
	{
		if (type() != ucl_type)
			throw type_mismatch(ucl_type, type());
	}

	// Create a new UCL string from a string.
	string(std::string_view value)
		: object(nihil::ucl::ref, 
			 ::ucl_object_fromstring_common(
				value.data(), value.size(),
				UCL_STRING_RAW))
	{
		if (_object == nullptr)
			throw error("failed to create UCL object");
	}

	// Create a new UCL string from an iterator pair.
	template<std::contiguous_iterator Iterator>
	string(Iterator first, Iterator last)
		: string(std::string_view(first, last))
	{}

	template<std::input_iterator Iterator>
	requires(!std::contiguous_iterator<Iterator>)
	string(Iterator first, Iterator last)
		: string(std::string(first, last))
	{}

	// Create a new UCL string from a range.
	string(std::from_range_t, std::ranges::range auto &&range)
		: string(std::ranges::begin(range),
			 std::ranges::end(range))
	{}

	// Return the value of this string.
	auto value(this string const &self) -> value_type
	{
		char const *dptr{};
		std::size_t dlen;

		auto const *uobj = self.get_ucl_object();
		if (::ucl_object_tolstring_safe(uobj, &dptr, &dlen))
			return {dptr, dlen};

		std::abort();
	}
};

/*
 * Comparison operators.
 */

export auto operator== (string const &a, string const &b)
	-> bool
{
	return a.value() == b.value();
}

export auto operator<=> (string const &a, string const &b)
	-> std::strong_ordering
{
	return a.value() <=> b.value();
}

export auto operator== (string const &a, string::value_type b)
	-> bool
{
	return a.value() == b;
}

export auto operator<=> (string const &a, string::value_type b)
	-> std::strong_ordering
{
	return a.value() <=> b;
}

} // namespace nihil::ucl

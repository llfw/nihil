/*
 * This source code is released into the public domain.
 */

module;

#include <concepts>
#include <functional>
#include <optional>
#include <utility>

export module nihil.guard;

namespace nihil {

/*
 * guard: invoke a callable when this object is destroyed; this is similar to
 * scope_exit from the library fundamentals TS, which LLVM doesn't implement.
 */
export template<std::invocable F>
struct guard final {
	// Initialise the guard with a callable we will invoke later.
	guard(F func) : m_func(std::move(func)) {}

	/*
	 * We are being destroyed, so call the callable.
	 * If the callable throws, std::terminate() will be called.
	 */
	~guard() {
		if (m_func)
			std::invoke(*m_func);
	}

	// Release the guard.  This turns the destructor into a no-op.
	void release() noexcept {
		m_func.reset();
	}

	// Not default-constructible, movable or copyable.
	guard() = delete;
	guard(guard const &) = delete;
	guard(guard &&) noexcept = delete;
	guard &operator=(guard const &) = delete;
	guard &operator=(guard &&) noexcept = delete;

private:
	// The callable to be invoked when we are destroyed.
	std::optional<F> m_func;
};

} // namespace nihil
